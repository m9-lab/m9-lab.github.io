(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{265:function(s,a,t){"use strict";t.r(a);var e=t(2),r=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"mysql"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[s._v("#")]),s._v(" Mysql")]),s._v(" "),t("p",[s._v("MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性")]),s._v(" "),t("h2",{attrs:{id:"基础架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础架构"}},[s._v("#")]),s._v(" 基础架构")]),s._v(" "),t("img",{attrs:{src:s.$withBase("/db/mysql/mysql-01.png"),alt:"foo"}}),s._v(" "),t("h3",{attrs:{id:"连接器管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#连接器管理"}},[s._v("#")]),s._v(" 连接器管理")]),s._v(" "),t("p",[s._v("首先是数据库连接器，主要负责和客户端建立连接、权限获取、管理连接等，由于整个建连的过程比较复杂，所以尽量使用长连接。如果数据库发生异常后为了快速恢复，可重启系统重新建立连接。")]),s._v(" "),t("ul",[t("li",[s._v("长连接：连接成功后，如果客户端持续有请求，则一直使用同一个连接")]),s._v(" "),t("li",[s._v("短链接：每次执行完很少的几次查询就断开连接，下次查询再重新建立一个")])]),s._v(" "),t("p",[s._v("链接的建立过程复杂，操作中如果需要大量长时间的存取数据，使用长链接\n使用长链接的缺点：\n容易占用内存， 因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM）")]),s._v(" "),t("p",[s._v("解决长连接占用内存，短链接繁琐的问题")]),s._v(" "),t("ol",[t("li",[s._v("定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。")]),s._v(" "),t("li",[s._v("如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行"),t("code",[s._v("mysql_reset_connection")]),s._v("来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。")])]),s._v(" "),t("h3",{attrs:{id:"mysql缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql缓存"}},[s._v("#")]),s._v(" Mysql缓存")]),s._v(" "),t("p",[s._v("key是查询的语句，value是查询的结果。Mysql通过在内存中建立"),t("code",[s._v("缓冲区[buffer]")]),s._v("和"),t("code",[s._v("缓寸[cache]")]),s._v("来提高Mysql性能, 对于InnoDB数据库，Mysql采用"),t("code",[s._v("缓冲池[buffer pool]")]),s._v("的方式来缓存数据和索引,对于MyISAM数据库，Mysql采用缓存的方式来缓存数据和索引,先看缓存数据，如果存在则直接返回。如果没有则直接往下走")]),s._v(" "),t("ul",[t("li",[s._v("关键字缓存（key cache）\n"),t("ul",[t("li",[s._v("当mysql收到传入的sql语句时，它首先和先前已经解析过的sql语句进行比较，如果发现相同，则返回已缓存数据。一定是完全相同,因此MySQL的查询缓存命中率很低")])])]),s._v(" "),t("li",[s._v("查询缓存（query cache）")])]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHOW")]),s._v(" variables "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("LIKE")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'have_query_cache'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 查询mysql缓存配置信息")]),s._v("\n")])])]),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("提示")]),s._v(" "),t("p",[s._v("对于一些不常改变的数据且有大量相同sql查询的表，查询缓存会节约很大的性能，对于频繁更改的表，查询缓存是不合适的")])]),s._v(" "),t("h3",{attrs:{id:"分析器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分析器"}},[s._v("#")]),s._v(" 分析器")]),s._v(" "),t("p",[s._v("对你执行的sql语句进行解析，首先是词法分析包括一些关键字识别，然后语法分析，查看这条语句是否符合mysql语句")]),s._v(" "),t("p",[s._v("分析器分析识别")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("词法分析")]),s._v("(识别关键字)：\n输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。\nMySQL从你输入的"),t("code",[s._v("SELECT")]),s._v('这个关键字识别出来，这是一个查询语句。它也要把字符串"T"识别成"表名T"，把字符串"ID"识别成"列ID"')]),s._v(" "),t("li",[t("strong",[s._v("语法分析")]),s._v(" (判断语法)：\n根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法\n如果语法不对，就会收到报错提醒，一般语法错误会提示第一个出现错误的位置\n即关注报错中的 "),t("code",[s._v("USE NEAR")])])]),s._v(" "),t("h3",{attrs:{id:"优化器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化器"}},[s._v("#")]),s._v(" 优化器")]),s._v(" "),t("p",[s._v("经过分析器的分析,Mysql就知道你要做的事情是什么了,但是，在开始执行之前，需要经过优化器的处理。发现那些查询命中索引，还有表之间的连接顺序等")]),s._v(" "),t("p",[s._v("优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联"),t("code",[s._v("JOIN")]),s._v("的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的"),t("code",[s._v("JOIN")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" T1 "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("JOIN")]),s._v(" T2 "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("USING")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("id"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" T1"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("c"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("AND")]),s._v(" T2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("d"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("20")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("p",[s._v("既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。\n也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。\n这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案")]),s._v(" "),t("h3",{attrs:{id:"执行器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行器"}},[s._v("#")]),s._v(" 执行器")]),s._v(" "),t("p",[s._v("通过上面一系列的验证，使用引擎提供的接口。经过不断的执行将查询的结果存放在结果集中，通过"),t("code",[s._v("EXPLAIN")]),s._v("可以看到执行器具体扫描了多少行。")]),s._v(" "),t("p",[s._v("经过优化器筛选优化的查询语句后，就进入执行器阶段，开始执行语句")]),s._v(" "),t("p",[s._v("开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示。")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" T "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" ID"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'")]),s._v("\n")])])]),t("p",[s._v("如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。")]),s._v(" "),t("p",[s._v("比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：")]),s._v(" "),t("p",[s._v('调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；\n调用引擎接口取"下一行"，重复相同的判断逻辑，直到取到这个表的最后一行。\n执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。\n至此，这个语句就执行完成了。')]),s._v(" "),t("p",[s._v('对于有索引的表，执行的逻辑也差不多。第一次调用的是"取满足条件的第一行"这个接口，之后循环取"满足条件的下一行"这个接口，这些接口都是引擎中已经定义好的。')]),s._v(" "),t("p",[s._v("你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。")]),s._v(" "),t("p",[s._v("在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟rows_examined并不是完全相同的")]),s._v(" "),t("h3",{attrs:{id:"sql语句的执行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sql语句的执行流程"}},[s._v("#")]),s._v(" SQL语句的执行流程")]),s._v(" "),t("p",[s._v("首先要清楚redo log和binlog两个日志模块")]),s._v(" "),t("ol",[t("li",[s._v("redo log（InnoDB特有的日志模块） 重做日志文件，用于记录事务操作的变化，记录修改后的值，不管事务是否提交。保证数据的完整性。其中redo log是固定大小的，是从头开始写，写到末尾在从头开始。同时会有两个指针，一个记录写入的位置，一个标记，当前擦除的位置，不断的循环。整个过程称为crash-safe。即时数据库异常，也会有记录")]),s._v(" "),t("li",[s._v("binlog 归档日志文件，用于记录对mysql数据库执行更改的所有操作。binlog是追加写，不会覆盖之前的。")])]),s._v(" "),t("p",[s._v("接下来介绍一下mysql更新一条语句的流程。")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UPDATE")]),s._v(" user_info "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SET")]),s._v(" name "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"marco"')]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" id "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("1. 首先执行器通过id查到这条记录(搜索树或者查找数据页)，并加载到内存中。\n2. 然后对这条记录的area_name调用引擎写入接口，进行修改。\n3. 修改内存中的值，同时更新redolog告知执行器完成写入（状态置为prepare），可以提交事务，执行器将这条操作记录记录在binlog，写入磁盘\n4. 完成上述一系列的操作，执行器调用事务提交接口（redolog状态置为commit），完成更新操作。\n")])])]),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("提示")]),s._v(" "),t("p",[s._v("注意：Mysql的redolog模块写入拆成2步走，prepare和commit，称为两阶段提交。 整个过程为1、redolog的prepare状态 2、binlog的写入")])]),s._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[s._v("redolog的commit状态，保证Mysql的可靠性。")])]),s._v(" "),t("p",[s._v("如果binlog没有写入并没有提交事务回滚\n如果binlog写入事务没提交，数据库回复后自动完成commit")]),s._v(" "),t("h2",{attrs:{id:"innodb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#innodb"}},[s._v("#")]),s._v(" InnoDB")]),s._v(" "),t("h2",{attrs:{id:"explain"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#explain"}},[s._v("#")]),s._v(" Explain")])])}),[],!1,null,null,null);a.default=r.exports}}]);